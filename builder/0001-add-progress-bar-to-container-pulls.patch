From 3b6cf38e69d064f6c50cb21afd56ea27e679dd5a Mon Sep 17 00:00:00 2001
From: antheas <git@antheas.dev>
Date: Tue, 14 May 2024 21:44:46 +0200
Subject: [PATCH] add progress bar to container pulls

---
 rust/src/sysroot_upgrade.rs | 52 ++++++++++++++++++++++++++++++++-----
 1 file changed, 46 insertions(+), 6 deletions(-)

diff --git a/rust/src/sysroot_upgrade.rs b/rust/src/sysroot_upgrade.rs
index fd1bec8d..47f58d00 100644
--- a/rust/src/sysroot_upgrade.rs
+++ b/rust/src/sysroot_upgrade.rs
@@ -56,10 +56,48 @@ fn layer_counts<'a>(layers: impl Iterator<Item = &'a ManifestLayerState>) -> (u3
     )
 }
 
-async fn layer_progress_print(mut r: Receiver<ImportProgress>) {
-    while let Some(v) = r.recv().await {
-        let msg = ostree_ext::cli::layer_progress_format(&v);
-        output_message(&msg);
+/// Write container fetch progress to standard output.
+pub async fn handle_layer_progress_print(
+    mut layers: Receiver<ImportProgress>,
+    mut layer_bytes: tokio::sync::watch::Receiver<Option<LayerProgress>>,
+) {
+    let style = indicatif::ProgressStyle::default_bar();
+    let pb = indicatif::ProgressBar::new(100);
+    pb.set_style(
+        style
+            .template("{prefix} {bytes} [{bar:20}] ({eta}) {msg}")
+            .unwrap(),
+    );
+    loop {
+        tokio::select! {
+            // Always handle layer changes first.
+            biased;
+            layer = layers.recv() => {
+                if let Some(l) = layer {
+                    if l.is_starting() {
+                        pb.set_position(0);
+                    } else {
+                        pb.finish();
+                    }
+                    pb.set_message(layer_progress_format(&l));
+                } else {
+                    // If the receiver is disconnected, then we're done
+                    break
+                };
+            },
+            r = layer_bytes.changed() => {
+                if r.is_err() {
+                    // If the receiver is disconnected, then we're done
+                    break
+                }
+                let bytes = layer_bytes.borrow();
+                if let Some(bytes) = &*bytes {
+                    pb.set_length(bytes.total);
+                    pb.set_position(bytes.fetched);
+                }
+            }
+
+        }
     }
 }
 
@@ -95,12 +133,14 @@ async fn pull_container_async(
     output_message(&format!("Pulling manifest: {}", &imgref));
     let mut imp = new_importer(repo, imgref).await?;
     let layer_progress = imp.request_progress();
+    let layer_byte_progress = imp.request_layer_progress();
+    let progress_printer = tokio::task::spawn(async move {
+        handle_layer_progress_print(layer_progress, layer_byte_progress).await
+    });
     let prep = match imp.prepare().await? {
         PrepareResult::AlreadyPresent(r) => return Ok(r.into()),
         PrepareResult::Ready(r) => r,
     };
-    let progress_printer =
-        tokio::task::spawn(async move { layer_progress_print(layer_progress).await });
     let digest = prep.manifest_digest.clone();
     output_message(&format!("Importing: {} (digest: {})", &imgref, &digest));
     let ostree_layers = prep
-- 
2.45.0

